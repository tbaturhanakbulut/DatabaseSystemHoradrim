% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\author{}
\date{}

\begin{document}

\begin{titlepage}
   \begin{center}
       \vspace*{1cm}

       \textbf{CMPE 321 Project 4}

       \vspace{0.5cm}
        Project Horadrim
            
       \vspace{1.5cm}

       \textbf{Harun ERKURT - 2016400300}
       
       \vspace{.5cm}
       
       \textbf{Taha Baturhan AKBULUT - 2019400087}

       \vfill
            
       May 28, 2022\\
            
       \vspace{0.8cm}
     
            
       Computer Engineering\\
       Bogazici University\\
       Turkey\\
            
   \end{center}
\end{titlepage}


\textbf{\hfill\break
}

\hypertarget{table-of-contents}{%
\section{Table of Contents}\label{table-of-contents}}

\protect\hyperlink{introduction}{1. Introduction 1}

\protect\hyperlink{assumptions-constraints}{2. Assumptions \&
Constraints 1}

\protect\hyperlink{assumptions}{2.1. Assumptions 1}

\protect\hyperlink{constraints}{2.2. Constraints 1}

\protect\hyperlink{storage-structures}{3. Storage Structures 2}

\protect\hyperlink{system-catalogue}{3.1. System Catalogue 2}

\protect\hyperlink{record}{3.2. Record 3}

\protect\hyperlink{page}{3.3. Page 3}

\protect\hyperlink{file}{3.4. File 4}

\protect\hyperlink{operations}{4. Operations 4}

\protect\hyperlink{horadrim-definition-language-operations}{4.1.
Horadrim Definition Language Operations 4}

\protect\hyperlink{horadrim-manipulation-language-operations}{4.2.
Horadrim Manipulation Language Operations 5}

\protect\hyperlink{how-b-plus-tree-works}{5. How B-Plus Tree Works 5}

\protect\hyperlink{conclusion-assessment}{6. Conclusion \& Assessment 6}

\hypertarget{introduction}{%
\section{\texorpdfstring{1. 
Introduction}{ Introduction}}\label{introduction}}

\begin{quote}
In this project we designed a database storage management system. This
system has records, pages, files and headers for these structures. The
reason we created headers is to be able to quickly insert, search and
delete operations. Pages, files and records structures help us to
efficiently handle storage and search operations. This structure
supports the creation, deletion, inheritance, and listing of type
operations; create, delete, search, update, list and filter operations
for records.
\end{quote}



  \hypertarget{assumptions-constraints}{%
  \section{2. Assumptions \& Constraints}\label{assumptions-constraints}}


    \hypertarget{assumptions}{%
    \subsubsection{2.1 Assumptions}\label{assumptions}}


\begin{itemize}
\item
  Each field has 20-byte space
\item
  Each page has 2667-byte space.
\item
  A file has 100 pages in it.
\item
  All fields are alphanumeric.
\item
  User always enters valid input
\item
  There is no null value for any field.
\item
  The inputs should be given in correct form.
\item
  The input lines should be given line by line.

    \hypertarget{constraints}{%
    \subsubsection{2.2 Constraints}\label{constraints}}
\end{itemize}

\begin{itemize}
\item
  The data must be organized in pages and pages must contain records.
\item
  It is must to use B+-Tree for indexing.
\item
  Primary keys of types should be used for the search-keys in trees.
\item
  There should be separate B+-Trees for each type, and these trees must
  be stored in file(s). So, when a type is created, its B+-Tree will
  also be created, and its structure should be stored.
\item
  With every create record and delete record operations, the
  corresponding tree should be updated.
\item
  B+-Trees should not be generated from scratch on the fly using records
  for DML operations. It should be utilized the tree structures that you
  stored in files. (We get the B-Plus Tree code from
  \url{https://github.com/NicolasLM/bplustree/tree/master/bplustree}.
  and we changed some parts to make it compatible with our own code.)
\item
  The data must be organized in pages and pages must contain records.
\item
  It is not allowed to store all pages in the same file and a file must
  contain multiple pages. This means that your system must be able to
  create new files as Horadrim grows. Moreover, when a file becomes free
  due to deletions, that file must be deleted.
\item
  Although a file contains multiple pages, it must read page by page
  when it is needed. Loading the whole file to RAM is not allowed.
\end{itemize}

  \hypertarget{storage-structures}{%
  \section{3. Storage Structures}\label{storage-structures}}

    \hypertarget{system-catalogue}{%
    \subsubsection{3.1 System Catalogue}\label{system-catalogue}}

The system catalog~consists of tables and views that describe the
structure of the database. System catalogue gives us metadata of our
database storage system. We used system catalogue files frequently. The
system catalog has made our work very comfortable. It has become very
easy to do some checks. We controlled type names to create a new type
for if there exists before. Attribute Catalog holds:

\begin{itemize}
\item
  Relation Name
\item
  Attributes
\item
  Attribute Types
\item
  Positions
\end{itemize}

\begin{longtable}[]{@{}llll@{}}
\toprule
Attribute Catalog & Attributes & Attribute Types & Positions \\
\midrule
\endhead
Relation Name 1 & field & string & 1 \\
Relation Name 2 & field & string & 2 \\
\bottomrule
\end{longtable}

Relations Catalog holds:

\begin{itemize}
\item
  Relation
\item
  File Names
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\toprule
Relation Catalog & Field \\
\midrule
\endhead
Relation Name 1 & File Names \\
Relation Name 2 & File Names \\
\bottomrule
\end{longtable}

Primary Key Catalog holds:

\begin{itemize}
\item
  Relation Name
\item
  Primary Key
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\toprule
Primary Key Catalog & Field \\
\midrule
\endhead
Relation Name 1 & Primary Key \\
Relation Name 2 & Primary Key \\
\bottomrule
\end{longtable}

Index Catalog holds:

\begin{itemize}
\item
  Primary Key
\item
  Index
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\toprule
Index Catalog & Field \\
\midrule
\endhead
Primary Key & Index 1 \\
Primary Key & Index 2 \\
\bottomrule
\end{longtable}

Relation Index Catalog holds:

\begin{itemize}
\item
  Relation Name
\item
  Index
\end{itemize}

\begin{longtable}[]{@{}ll@{}}
\toprule
Relation Index Catalog & Field \\
\midrule
\endhead
Relation Name 1 & Index 1 \\
Relation Name 2 & Index 2 \\
\bottomrule
\end{longtable}

\hypertarget{record}{%
\subsubsection{3.2 Record}\label{record}}

For each type, we should make calculations. We are assuming each field
is 252 bytes. Total size of a record is 263 bytes. Record header holds
an integer for checking if there is a record, rid, and fields.

\begin{longtable}[]{@{}llll@{}}
\toprule
Record Header & Field & Record Id & Field \\
\midrule
\endhead
Record & 0 & 0 & Null \\
Record & 0 & 1 & Null \\
Record & 0 & 2 & Null \\
Record & 0 & 3 & Null \\
Record & 0 & 4 & Null \\
Record & 0 & 5 & Null \\
Record & 1 & 6 & angel Tyrael ArchangelOfJustice HighHeavens \\
\bottomrule
\end{longtable}

\hypertarget{page}{%
\subsubsection{3.3 Page}\label{page}}

Page is a piece of data that is stored to disk as a unit. It is must for
B-Plus Tree to store the number of records in a single node. Simply page
holds records. Each page has 2667 bytes storage space for records. Every
page has one type of records. Record per page is equal to 10. Page
header is 37 bytes, so we have 2630 byte for records. Page header holds
Page name, available record count and page id. Page id is required for
indexing when using B-Plus Tree. When scanning file page by page, we
compare the type that we searched with the type in the page header. And,
we add the types of all the pages in the file to the files header to
scan efficiently.

\begin{longtable}[]{@{}llll@{}}
\toprule
Page Header: & Page Name & Aver. Record Count & Page id \\
\midrule
\endhead
Record Header: & 0 & 0 & Null \\
Record Header: & 0 & 1 & Null \\
Record Header: & 0 & 2 & Null \\
Record Header: & 0 & 3 & Null \\
Record Header: & 0 & 4 & Null \\
Record Header: & 0 & 5 & Null \\
Record Header: & 0 & 6 & Null \\
Record Header: & 0 & 7 & Null \\
Record Header: & 1 & \emph{8} & angel Tyrael ArchangelOfJustice
HighHeavens \\
Record Header: & 0 & 9 & Null \\
\bottomrule
\end{longtable}

\hypertarget{file}{%
\subsubsection{3.4 File}\label{file}}

Files have 100 pages. File header holds types of pages, Total pages in
that file, and page id. We know page. File organization is the advanced
method of an indexed sequential access method. It uses a tree-like
structure to store the records in File. We can search every record using
file. We are pulling types from file and pid.

\begin{longtable}[]{@{}llll@{}}
\toprule
File Header: & Types of Pages & Total Pages & Page Id \\
\midrule
\endhead
Page: & Angel & 10 & 0 \\
Record Header: & 0 & 0 & Null \\
Record Header: & 0 & 1 & Null \\
Record Header: & 0 & 2 & Null \\
Record Header: & 0 & 3 & Null \\
Record Header: & 0 & 4 & Null \\
Record Header: & 1 & 5 & angel Tyrael \\
\bottomrule
\end{longtable}

\hypertarget{operations}{%
\section{4. Operations}\label{operations}}

Definition Language Operations:

\begin{itemize}
\item
  Create Type
\item
  Delete Type
\item
  List Type
\end{itemize}

Manipulation Language Operations:

\begin{itemize}
\item
  Create Record
\item
  Delete Record
\item
  Search for a record (by primary key)
\item
  Update a record (by primary key)
\item
  List all records of a type
\item
  Filter records (by primary key)

    \hypertarget{horadrim-definition-language-operations}{%
    \subsubsection{4.1 Horadrim Definition Language
    Operations}\label{horadrim-definition-language-operations}}
\end{itemize}

Create Type

\begin{itemize}
\item
  Get input from user, which contains ``create type'' and field names.
\item
  Looks for all files that if it contains current type page.
\item
  Splits attributes
\item
  Stores attributes
\item
  Creates new page with give instructions
\item
  Takes file with given type.
\item
  If type already exists, return error.
\item
  Adds page to taken file.
\item
  Then adds the metadata to the relevant catalogs
\end{itemize}

Delete Type

\begin{itemize}
\item
  Get input from user, which contains ``delete type'' and field names.
\item
  Then searches file name ends with .txt if given type name exists.
\item
  If it exists, deletes the given type from the file containing the
  type.
\item
  Prints log to log file.
\end{itemize}

List Type

\begin{itemize}
\item
  Get input from user, which contains ``list type''.
\item
  Searches files for given type name
\item
  And lists if the type exists.

    \hypertarget{horadrim-manipulation-language-operations}{%
    \subsubsection{4.2 Horadrim Manipulation Language
    Operations}\label{horadrim-manipulation-language-operations}}
\end{itemize}

Create

\begin{itemize}
\item
  Get input from user, which contains ``create record'' operation and
  type name and field values.
\item
    Checks if the same record name is given.
\item
    Starting from the last file, checks file header for insertion.
\item
    Checks if given record id exists.
\item
    After passing all the tests, scans the file to see if there is a suitable page to place the record.
\item
    If it cannot find the appropriate file, it searches for the appropriate file and creates a new page there. If it doesn't exist, it opens a new file and puts the record there. Prints log.

\end{itemize}

Delete

\begin{itemize}
\item
  Get input from user, which contains ``delete record'' operation and
  type name and primary key.
\item
    Checks if the record name exists.
\item
    Starting from the last file, checks file header for deletion.
\item
    Checks if given record id exists.
\item
    After passing all the tests, scans the file to find record.
\item
    Last, deletes the record from the file and move all records below the deleted record up one line. Prints log.

\end{itemize}

Update

\begin{itemize}
\item
  Get input from user, which contains ``update record'' operation and
  type name, primary key and field values.
\item
    Checks if the same record name is given or not from catalog.
\item
    Starting from the last file, checks file header for updating.
\item
    After passing all the tests, scans the file to find the key.
\item
    If it does not exist print failure to log.
\item
    If it exists update the record. Print success to log.
    
\end{itemize}

Search

\begin{itemize}
\item
  Get input from user, which contains ``search record'' operation and
  type name and record id.
\item
    Checks catalog for given type name.
\item
    If the name does not exists in the catalog, print failure to log.
\item
    After passing all the tests, scans the file to find record.
\item
    If the record exists prints the record. Prints success to log.
    
\end{itemize}

List

\begin{itemize}
\item
  Get input from user, which contains ``list record'' operation and type
  name.
\item
  Reads catalog from given file name.
\item
  If given type does not exists in the catalog prints failure.
\item
  After passing all the tests, scans the file to find page.
\item
  Prints list. Prints success to log.

\end{itemize}

Filter

\begin{itemize}
\item
  Get input from user, which contains ``filter record'' operation and
  type name and condition
\item
  Reads catalog from given type name.
\item
  Starting from last created file checks all record and if given condition is there, prints it to output file. Prints success to log.
\item
  if given condition is not there, prints failure to log.
\end{itemize}

\hypertarget{how-b-plus-tree-works}{%
\section{5. How B-Plus Tree Works}\label{how-b-plus-tree-works}}

While defining the B-Plus tree object, we only gave file name and string
serializer. We use close function to close the B-Plus Tree. For
insertion there is an insert function that gets key and value. We use
get function to search a value using primary key. In searching, firstly
compares key with the root node. If key is bigger than current, goes to
right child, else goes to left child. Lastly finds the right index. In
insertion B Plus Tree finds a location at the leaf nodes. If the leaf
node's key is less than m-1 inserts a node in increasing order. If node
keys equal to m-1, then inserts a new item inn increasing number of
items. Takes medians and splits into two nodes and pushes median to its
parent node. If parent node key equals to m-1, repeats the procedure.
Lastly inserts the element. In deletion, if node is bigger than m/2,
deletes the given key from the node. Else if the left child contains m/2
elements, pushes the bigger element to the parent and deletes the key.
If right child contains m/2 elements, pushes smallest element to parent.

\hypertarget{conclusion-assessment}{%
\section{6. Conclusion \& Assessment}\label{conclusion-assessment}}

We tried to generate the B-Plus Tree from scratch and then we were told
that we don't need to do it that way. Then we get the B-Plus Tree code
from \url{https://github.com/NicolasLM/bplustree/tree/master/bplustree}.
And we changed some parts to make it compatible with our own code. We
implemented system catalog and type systems for metadata. We kept all
the catalogs in separate files, but actually we could have kept them in
a single file called the system catalog

\end{document}